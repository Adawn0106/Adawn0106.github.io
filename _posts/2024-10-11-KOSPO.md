---
layout: post
read_time: true
show_date: true
title: "KOSPO Write Up"
date: 2024-10-11
img: posts/20241011/한국남부발전.png
tags: [CTF, Write up]
category: review
author: adawn0106
description: "Introduction to the Problems I Solved at KOSPO"
comments: true

---

I recently participated in the KOSPO competition hosted by Korea Southern Power.
The problems were more diverse than I expected and not too difficult, so it was great to be able to try all of them, even though I couldn't solve many.

![scoreboard](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/scoreboard.png)


1. Bonus 1

[view?usp=sharing](https://drive.google.com/file/d/1CjavoPcD3eQihExUQ4XvebUcsNszg9Q-/view?usp=sharing)

Helloworld.apk

When I downloaded the problem, I received a file like this.

To understand how the APK functions, I ran it using Nox.

![NOX](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/NOX.png)



This screen appeared, but I couldn’t find any other meaningful information.

I proceeded to analyze the APK further using Jadx.

![Jadx.png](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/Jadx.png)


During the analysis with Jadx, I found a hint in the BuildConfig file.

```bash
public static final String kospo_hint = "CN+C+OU+ST+L+O=Base64";
```

This value seemed to suggest that the fields needed to be concatenated and then converted to Base64.

After researching with GPT, I found out what this information meant.

In an APK file, "CN+C+OU+ST+L+O=Base64" generally represents the subject information from the certificate used to sign the APK. Each field provides details about the issuer or owner of the certificate, following the X.509 standard.

The fields indicate the following information:

CN (Common Name): Typically refers to the name of the issuer or domain.
C (Country Name): Represents the country code (e.g., KR for Korea, US for the United States).
OU (Organizational Unit): Refers to the department within the organization.
ST (State or Province Name): The name of the state or province.
L (Locality Name): The name of the city or locality.
O (Organization Name): The name of the organization or company.
This string is Base64-encoded, meaning it was converted from its original form to prevent data corruption during transmission. Base64 encoding converts binary data into text.

Thus, "CN+C+OU+ST+L+O=Base64" refers to the certificate's subject information that has been Base64-encoded.

By examining this information, I identified the following certificate details:

```bash
CN=U21hc, OU=5lcmd, O=l9MaWZl, L=dHRlc, ST=5X0Jl, C=nRfRW
```

These values seemed odd, so I concatenated them in the appropriate order:

```bash
U21hcnRfRW5lcmd5X0JldHRlcl9MaWZl
```

After obtaining this string, I used Cyberchef to decode it from Base64.

```bash
Smart_Energy_Better_Life
```

2. Bonus 2

This was the first time I got a "first blood" on a challenge during a competition or CTF  (I probably won’t get another one in the future.)

I solved this challenge on my laptop, but I accidentally deleted the files, so I’ll briefly explain the situation before getting into the details.

The challenge provided a .py file and a video file.

The Python script was designed to break the video down into frames, but when I played the video, I couldn’t directly see any values that resembled the flag. I figured the solution would be to inspect the frames one by one.

Below is the modified version of the code I was provided with, which ended up being the solution:

```bash
import cv2
import os

# Path to the video file (relative path) 
video_path = 'problem.mp4'

# Directory path where the script is executed
current_folder = os.path.dirname(os.path.abspath(__file__))

# Set the save path for images in the current folder
save_path = os.path.join(current_folder, "img")
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Open the video file
vidcap = cv2.VideoCapture(video_path)

count = 0

# Check if the video file was opened successfully
if not vidcap.isOpened():
    print(f"Error: Could not open video file at {video_path}")
else:
    print(f"Video file opened successfully: {video_path}")

# Read the frames while the video is opened
while vidcap.isOpened():
    ret, image = vidcap.read()

    if not ret:
        print("Error: Could not read frame or video finished.")
        break

    try:
        if int(vidcap.get(1)) % 1 == 0:  # Save every frame
            print(f"Saving frame number: {int(vidcap.get(1))}")
            cv2.imwrite(os.path.join(save_path, "%d.jpg" % count), image)
            print(f"Saved frame {count}.jpg")
            count += 1
    except Exception as e:
        print(f"An error occurred during frame processing: {e}")
        break

vidcap.release()
print("Video processing complete.")

```

When this code is executed, it breaks the video down into individual frames and saves them as images.

After checking all the frames one by one, I found the flag between frames 200 and 300, if I remember correctly.

The video was related to Mala Tang, so the flag was {TangHooR00}.


3.Bonus 4

어지간히 나를 괴롭힌 문제. (~~파이리는 이제 영영 싫어할듯~~)

문제 파일을 다운로드 받아보면 

![bonus4.zip](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/bonus4.zip)

파이리 사진을 하나 던져준다. 문제의 설명은 파이리를 진화시켜라! 였었는데 우선 스테가노그라피인가 싶어 확인을 해보았지만 별 다른 이상은 없었다.

그래서 HXD로 뜯어서 확인을 해보았다. 

그랬더니 매직 넘버를 3개를 찾을 수 있어 복합적으로 합쳐진 파일이라는 것을 알 수 있었다.

1.

![hex1](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/hex1.png)

2.

![hex2](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/hex2.png)

3.

![hex3](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/hex3.png)

이럴 경우 해결 방법이 두가지가 있는데 간단한 방법을 소개하기전에 알아야할 것은 PNG 파일의 

구조이다.

PNG 파일의 시작은 해당 매직넘버부터 IEND로 끝나게 된다. 이점을 잘 기억해서 이미지들을 추출하면 아래의 사진들을 다 볼 수 있다. 

또 다른 방법은 Binwalk를 통해서 숨겨진 파일들을 찾는 방법인데 해당 툴을 사용하면 안에 어떠한 파일이 있는지 알려주고 foremost라는 명령어를 사용하여 파일들을 추출해서 볼 수 있다. 

앞으로도 많이 사용할 거 같아서 잘 기억해두면 좋을 것 같다. 

![파이리](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/파이리.png)

![파이리2](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/파이리2.png)

![파이리3](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/파이리3.png)

이 리자몽을 보고 이제 다 푼건가라는 생각을 했지만 flag는 어디에도 없었다.. 

스테가노그라피고 크기늘려보고 다 해보았지만 아무것도 나오지 않아서 문제를 풀면서 

일단 놔두고 다른 문제들을 계속 풀었다. 

시간이 끝나고 다른 사람들이 본 write up을 보면서 알게되었는데 너비랑 높이 조정을 하면 보인다고 한다. 

![hexedit](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/edit.png)

해당 부분이 너비와 높이를 고치는 HEX 값인데 저 부분을 어느정도 내가 조정하면서 사진을 확인해보았다.  그래서 아래처럼 해결하였다.

![flag](https://github.com/Adawn0106/Adawn0106.github.io/raw/main/assets/img/posts/20241011/flag.png)




